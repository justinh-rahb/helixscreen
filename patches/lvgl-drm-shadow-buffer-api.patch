--- a/src/drivers/display/drm/lv_linux_drm.c	2026-02-28 12:00:55.695836782 -0500
+++ b/src/drivers/display/drm/lv_linux_drm.c	2026-02-28 12:01:10.300197246 -0500
@@ -184,6 +184,13 @@
             }
         }
 
+        /* Shadow buffer mode: draw buffers are not DRM buffers, so no match.
+         * lv_linux_drm_set_active_buf() will set act_buf before flush. */
+        if(drm_dev->act_buf == NULL) {
+            LV_LOG_TRACE("Draw buffer not in DRM bufs (shadow buffer mode)");
+            return;
+        }
+
 #if LV_USE_LINUX_DRM_GBM_BUFFERS
         struct dma_buf_sync sync_req;
         sync_req.flags = DMA_BUF_SYNC_START | DMA_BUF_SYNC_RW;
@@ -294,6 +301,33 @@
     LV_LOG_INFO("DRM plane rotation set to %u", (unsigned)rotation);
 }
 
+uint8_t * lv_linux_drm_get_buf_map(lv_display_t * disp, int buf_index)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL || buf_index < 0 || buf_index >= BUFFER_CNT) {
+        return NULL;
+    }
+    return drm_dev->drm_bufs[buf_index].map;
+}
+
+uint32_t lv_linux_drm_get_buf_stride(lv_display_t * disp)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL) {
+        return 0;
+    }
+    return drm_dev->drm_bufs[0].pitch;
+}
+
+void lv_linux_drm_set_active_buf(lv_display_t * disp, int buf_index)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL || buf_index < 0 || buf_index >= BUFFER_CNT) {
+        return;
+    }
+    drm_dev->act_buf = &drm_dev->drm_bufs[buf_index];
+}
+
 /**********************
  *   STATIC FUNCTIONS
  **********************/
@@ -1120,7 +1154,10 @@
     LV_UNUSED(px_map);
     drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
 
-    LV_ASSERT(drm_dev->act_buf != NULL);
+    if(drm_dev->act_buf == NULL) {
+        LV_LOG_ERROR("act_buf is NULL at flush time â€” skipping page flip");
+        return;
+    }
 
     if(drm_dmabuf_set_plane(drm_dev, drm_dev->act_buf)) {
         LV_LOG_ERROR("Flush fail");
--- a/src/drivers/display/drm/lv_linux_drm.h	2026-02-28 12:00:55.696572415 -0500
+++ b/src/drivers/display/drm/lv_linux_drm.h	2026-02-28 12:01:18.012375477 -0500
@@ -115,6 +115,40 @@
 void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation);
 
 /**
+ * @brief Get a pointer to a DRM dumb buffer's mapped memory
+ *
+ * Returns the mmap'd address of the specified DRM framebuffer.
+ * Used by the shadow buffer rotation path to write rotated pixels
+ * directly into the page-flip target.
+ *
+ * @param disp      Pointer to the display object
+ * @param buf_index Buffer index (0 or 1)
+ * @return Pointer to the buffer's mapped memory, or NULL
+ */
+uint8_t * lv_linux_drm_get_buf_map(lv_display_t * disp, int buf_index);
+
+/**
+ * @brief Get the stride (pitch) of the DRM dumb buffers
+ *
+ * @param disp      Pointer to the display object
+ * @return Buffer stride in bytes, or 0 on error
+ */
+uint32_t lv_linux_drm_get_buf_stride(lv_display_t * disp);
+
+/**
+ * @brief Force the active buffer for the next page flip
+ *
+ * Overrides the automatic buffer selection (drm_dmabuf_set_active_buf)
+ * so the next flush page-flips to the specified buffer. Used by the
+ * shadow buffer rotation path which writes directly to a DRM buffer
+ * that isn't one of LVGL's draw buffers.
+ *
+ * @param disp      Pointer to the display object
+ * @param buf_index Buffer index (0 or 1) to page-flip to
+ */
+void lv_linux_drm_set_active_buf(lv_display_t * disp, int buf_index);
+
+/**
  * Get the horizontal resolution of a DRM mode
  * @param mode pointer to the DRM mode object
  * @return horizontal resolution in pixels, or 0 if mode is invalid
