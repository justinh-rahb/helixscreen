diff --git a/src/drivers/display/drm/lv_linux_drm.c b/src/drivers/display/drm/lv_linux_drm.c
index 2a6ca6ed0..3c986c8ee 100644
--- a/src/drivers/display/drm/lv_linux_drm.c
+++ b/src/drivers/display/drm/lv_linux_drm.c
@@ -78,6 +78,7 @@ typedef struct {
     drmModePropertyPtr conn_props[128];
     drm_buffer_t drm_bufs[BUFFER_CNT];
     drm_buffer_t * act_buf;
+    uint64_t plane_rotation; /* DRM_MODE_ROTATE_* bitmask, 0 = unset */
 #if LV_USE_LINUX_DRM_GBM_BUFFERS
     struct gbm_device * gbm_device;
 #endif
@@ -256,6 +257,43 @@ void lv_linux_drm_set_mode_cb(lv_display_t * disp, lv_linux_drm_select_mode_cb_t
     LV_UNUSED(callback);
     LV_LOG_WARN("DRM without EGL support doesn't currently support setting a mode selection callback");
 }
+
+uint64_t lv_linux_drm_get_plane_rotation_mask(lv_display_t * disp)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL) {
+        return 0;
+    }
+
+    uint32_t i;
+    for(i = 0; i < drm_dev->count_plane_props; ++i) {
+        if(lv_strcmp(drm_dev->plane_props[i]->name, "rotation") == 0) {
+            drmModePropertyPtr prop = drm_dev->plane_props[i];
+            uint64_t mask = 0;
+            int e;
+            for(e = 0; e < prop->count_enums; ++e) {
+                mask |= (1ULL << prop->enums[e].value);
+            }
+            LV_LOG_INFO("DRM plane rotation mask: 0x%x (%d enums)", (unsigned)mask, prop->count_enums);
+            return mask;
+        }
+    }
+
+    LV_LOG_INFO("DRM plane has no rotation property");
+    return 0;
+}
+
+void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL) {
+        LV_LOG_ERROR("DRM display not initialized");
+        return;
+    }
+    drm_dev->plane_rotation = rotation;
+    LV_LOG_INFO("DRM plane rotation set to %u", (unsigned)rotation);
+}
+
 /**********************
  *   STATIC FUNCTIONS
  **********************/
@@ -482,6 +520,10 @@ static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf)
     drm_add_plane_property(drm_dev, "CRTC_W", drm_dev->width);
     drm_add_plane_property(drm_dev, "CRTC_H", drm_dev->height);
 
+    if(drm_dev->plane_rotation) {
+        drm_add_plane_property(drm_dev, "rotation", drm_dev->plane_rotation);
+    }
+
     ret = drmModeAtomicCommit(drm_dev->fd, drm_dev->req, flags, drm_dev);
     if(ret) {
         LV_LOG_ERROR("drmModeAtomicCommit failed: %s (%d)", strerror(errno), errno);
@@ -508,7 +550,10 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         return -1;
     }
 
-    LV_LOG_TRACE("drm: found planes %u", planes->count_planes);
+    LV_LOG_INFO("drm: found %u planes, looking for fourcc %c%c%c%c on crtc_idx %u",
+                planes->count_planes,
+                (fourcc >> 0) & 0xff, (fourcc >> 8) & 0xff,
+                (fourcc >> 16) & 0xff, (fourcc >> 24) & 0xff, crtc_idx);
 
     for(i = 0; i < planes->count_planes; ++i) {
         plane = drmModeGetPlane(drm_dev->fd, planes->planes[i]);
@@ -519,6 +564,8 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         }
 
         if(!(plane->possible_crtcs & (1 << crtc_idx))) {
+            LV_LOG_INFO("drm: plane %u: crtc_mask=0x%x, skipping (need bit %u)",
+                        plane->plane_id, plane->possible_crtcs, crtc_idx);
             drmModeFreePlane(plane);
             continue;
         }
@@ -529,6 +576,8 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         }
 
         if(j == plane->count_formats) {
+            LV_LOG_INFO("drm: plane %u: no matching fourcc among %u formats",
+                        plane->plane_id, plane->count_formats);
             drmModeFreePlane(plane);
             continue;
         }
@@ -536,7 +585,7 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         *plane_id = plane->plane_id;
         drmModeFreePlane(plane);
 
-        LV_LOG_TRACE("found plane %d", *plane_id);
+        LV_LOG_INFO("drm: found suitable plane %d", *plane_id);
 
         /* Success */
         goto out;
@@ -579,16 +628,16 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
         }
 
         if(conn->connection == DRM_MODE_CONNECTED) {
-            LV_LOG_TRACE("drm: connector %d: connected", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: connected (%d modes)", conn->connector_id, conn->count_modes);
         }
         else if(conn->connection == DRM_MODE_DISCONNECTED) {
-            LV_LOG_TRACE("drm: connector %d: disconnected", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: disconnected", conn->connector_id);
         }
         else if(conn->connection == DRM_MODE_UNKNOWNCONNECTION) {
-            LV_LOG_TRACE("drm: connector %d: unknownconnection", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: unknownconnection", conn->connector_id);
         }
         else {
-            LV_LOG_TRACE("drm: connector %d: unknown", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: unknown", conn->connector_id);
         }
 
         if(conn->connection == DRM_MODE_CONNECTED && conn->count_modes > 0)
@@ -604,7 +653,7 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
     }
 
     drm_dev->conn_id = conn->connector_id;
-    LV_LOG_TRACE("conn_id: %d", drm_dev->conn_id);
+    LV_LOG_INFO("drm: using connector %d", drm_dev->conn_id);
     drm_dev->mmWidth = conn->mmWidth;
     drm_dev->mmHeight = conn->mmHeight;
 
@@ -635,9 +684,8 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
 
     if(enc) {
         drm_dev->enc_id = enc->encoder_id;
-        LV_LOG_TRACE("enc_id: %d", drm_dev->enc_id);
         drm_dev->crtc_id = enc->crtc_id;
-        LV_LOG_TRACE("crtc_id: %d", drm_dev->crtc_id);
+        LV_LOG_INFO("drm: encoder %d, crtc %d", drm_dev->enc_id, drm_dev->crtc_id);
         drmModeFreeEncoder(enc);
         enc = NULL;
     }
@@ -698,7 +746,7 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
         goto free_res;
     }
 
-    LV_LOG_TRACE("crtc_idx: %d", drm_dev->crtc_idx);
+    LV_LOG_INFO("drm: crtc_idx: %d", drm_dev->crtc_idx);
     ret = 0;
 
 free_res:
@@ -1074,6 +1122,36 @@ static void drm_flush(lv_display_t * disp, const lv_area_t * area, uint8_t * px_
 
     LV_ASSERT(drm_dev->act_buf != NULL);
 
+    /* Software 180Â° rotation via shadow buffer.
+     * Copy pixels in reverse order to a temp buffer, then bulk-copy back.
+     * The single memcpy back prevents tearing (in-place swap is visible
+     * to the DRM scanout as it progresses through the buffer).
+     * When rotation is inactive, free the shadow buffer to save ~1.5 MB. */
+    static uint32_t * rot_buf = NULL;
+    static uint32_t rot_buf_size = 0;
+    if(lv_display_get_rotation(disp) == LV_DISPLAY_ROTATION_180) {
+        uint32_t total = drm_dev->width * drm_dev->height;
+        uint32_t needed = total * sizeof(uint32_t);
+        if(rot_buf == NULL || rot_buf_size < needed) {
+            lv_free(rot_buf);
+            rot_buf = lv_malloc(needed);
+            rot_buf_size = needed;
+        }
+        if(rot_buf) {
+            uint32_t * src = (uint32_t *)drm_dev->act_buf->map;
+            uint32_t i;
+            for(i = 0; i < total; i++) {
+                rot_buf[i] = src[total - 1 - i];
+            }
+            lv_memcpy(drm_dev->act_buf->map, rot_buf, needed);
+        }
+    }
+    else if(rot_buf != NULL) {
+        lv_free(rot_buf);
+        rot_buf = NULL;
+        rot_buf_size = 0;
+    }
+
     if(drm_dmabuf_set_plane(drm_dev, drm_dev->act_buf)) {
         LV_LOG_ERROR("Flush fail");
         return;
diff --git a/src/drivers/display/drm/lv_linux_drm.h b/src/drivers/display/drm/lv_linux_drm.h
index 5afede049..fa1b28b56 100644
--- a/src/drivers/display/drm/lv_linux_drm.h
+++ b/src/drivers/display/drm/lv_linux_drm.h
@@ -90,6 +90,30 @@ char * lv_linux_drm_find_device_path(void);
  */
 void lv_linux_drm_set_mode_cb(lv_display_t * disp, lv_linux_drm_select_mode_cb_t callback);
 
+/**
+ * @brief Query the DRM plane's supported rotation bitmask
+ *
+ * Iterates the plane properties to find the "rotation" property and builds
+ * a bitmask from its enum values. Returns 0 if no rotation property exists.
+ *
+ * @param disp      Pointer to the display object created with lv_linux_drm_create()
+ * @return Bitmask of supported DRM_MODE_ROTATE_* values, or 0
+ */
+uint64_t lv_linux_drm_get_plane_rotation_mask(lv_display_t * disp);
+
+/**
+ * @brief Set the DRM plane rotation property
+ *
+ * Configures the hardware rotation via the DRM plane "rotation" property.
+ * This is necessary because LVGL's software rotation (lv_display_set_rotation)
+ * does not work with LV_DISPLAY_RENDER_MODE_DIRECT used by the DRM backend.
+ *
+ * @param disp      Pointer to the display object created with lv_linux_drm_create()
+ * @param rotation  DRM rotation bitmask (DRM_MODE_ROTATE_0, DRM_MODE_ROTATE_90,
+ *                  DRM_MODE_ROTATE_180, DRM_MODE_ROTATE_270)
+ */
+void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation);
+
 /**
  * Get the horizontal resolution of a DRM mode
  * @param mode pointer to the DRM mode object
@@ -118,6 +142,29 @@ int32_t lv_linux_drm_mode_get_refresh_rate(const lv_linux_drm_mode_t * mode);
  */
 bool lv_linux_drm_mode_is_preferred(const lv_linux_drm_mode_t * mode);
 
+#if LV_LINUX_DRM_USE_EGL
+/**
+ * Get the EGL display from a DRM display (cast to EGLDisplay)
+ * @param disp pointer to the display object
+ * @return EGLDisplay as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_display(lv_display_t * disp);
+
+/**
+ * Get the EGL context from a DRM display (cast to EGLContext)
+ * @param disp pointer to the display object
+ * @return EGLContext as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_context(lv_display_t * disp);
+
+/**
+ * Get the EGL config from a DRM display (cast to EGLConfig)
+ * @param disp pointer to the display object
+ * @return EGLConfig as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_config(lv_display_t * disp);
+#endif
+
 /**********************
  *      MACROS
  **********************/
