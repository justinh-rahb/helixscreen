diff --git a/src/drivers/display/drm/lv_linux_drm.c b/src/drivers/display/drm/lv_linux_drm.c
index 2a6ca6ed0..dcbce6617 100644
--- a/src/drivers/display/drm/lv_linux_drm.c
+++ b/src/drivers/display/drm/lv_linux_drm.c
@@ -78,6 +78,7 @@ typedef struct {
     drmModePropertyPtr conn_props[128];
     drm_buffer_t drm_bufs[BUFFER_CNT];
     drm_buffer_t * act_buf;
+    uint64_t plane_rotation; /* DRM_MODE_ROTATE_* bitmask, 0 = unset */
 #if LV_USE_LINUX_DRM_GBM_BUFFERS
     struct gbm_device * gbm_device;
 #endif
@@ -256,6 +257,18 @@ void lv_linux_drm_set_mode_cb(lv_display_t * disp, lv_linux_drm_select_mode_cb_t
     LV_UNUSED(callback);
     LV_LOG_WARN("DRM without EGL support doesn't currently support setting a mode selection callback");
 }
+
+void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL) {
+        LV_LOG_ERROR("DRM display not initialized");
+        return;
+    }
+    drm_dev->plane_rotation = rotation;
+    LV_LOG_INFO("DRM plane rotation set to %u", (unsigned)rotation);
+}
+
 /**********************
  *   STATIC FUNCTIONS
  **********************/
@@ -482,6 +495,10 @@ static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf)
     drm_add_plane_property(drm_dev, "CRTC_W", drm_dev->width);
     drm_add_plane_property(drm_dev, "CRTC_H", drm_dev->height);
 
+    if(drm_dev->plane_rotation) {
+        drm_add_plane_property(drm_dev, "rotation", drm_dev->plane_rotation);
+    }
+
     ret = drmModeAtomicCommit(drm_dev->fd, drm_dev->req, flags, drm_dev);
     if(ret) {
         LV_LOG_ERROR("drmModeAtomicCommit failed: %s (%d)", strerror(errno), errno);
diff --git a/src/drivers/display/drm/lv_linux_drm.h b/src/drivers/display/drm/lv_linux_drm.h
index 5afede049..7f74a327c 100644
--- a/src/drivers/display/drm/lv_linux_drm.h
+++ b/src/drivers/display/drm/lv_linux_drm.h
@@ -90,6 +90,19 @@ char * lv_linux_drm_find_device_path(void);
  */
 void lv_linux_drm_set_mode_cb(lv_display_t * disp, lv_linux_drm_select_mode_cb_t callback);
 
+/**
+ * @brief Set the DRM plane rotation property
+ *
+ * Configures the hardware rotation via the DRM plane "rotation" property.
+ * This is necessary because LVGL's software rotation (lv_display_set_rotation)
+ * does not work with LV_DISPLAY_RENDER_MODE_DIRECT used by the DRM backend.
+ *
+ * @param disp      Pointer to the display object created with lv_linux_drm_create()
+ * @param rotation  DRM rotation bitmask (DRM_MODE_ROTATE_0, DRM_MODE_ROTATE_90,
+ *                  DRM_MODE_ROTATE_180, DRM_MODE_ROTATE_270)
+ */
+void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation);
+
 /**
  * Get the horizontal resolution of a DRM mode
  * @param mode pointer to the DRM mode object
@@ -118,6 +131,29 @@ int32_t lv_linux_drm_mode_get_refresh_rate(const lv_linux_drm_mode_t * mode);
  */
 bool lv_linux_drm_mode_is_preferred(const lv_linux_drm_mode_t * mode);
 
+#if LV_LINUX_DRM_USE_EGL
+/**
+ * Get the EGL display from a DRM display (cast to EGLDisplay)
+ * @param disp pointer to the display object
+ * @return EGLDisplay as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_display(lv_display_t * disp);
+
+/**
+ * Get the EGL context from a DRM display (cast to EGLContext)
+ * @param disp pointer to the display object
+ * @return EGLContext as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_context(lv_display_t * disp);
+
+/**
+ * Get the EGL config from a DRM display (cast to EGLConfig)
+ * @param disp pointer to the display object
+ * @return EGLConfig as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_config(lv_display_t * disp);
+#endif
+
 /**********************
  *      MACROS
  **********************/
