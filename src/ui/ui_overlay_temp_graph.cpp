// Copyright (C) 2025-2026 356C LLC
// SPDX-License-Identifier: GPL-3.0-or-later

#include "ui_overlay_temp_graph.h"

#include "app_globals.h"
#include "moonraker_api.h"
#include "observer_factory.h"
#include "panel_widget_manager.h"
#include "printer_state.h"
#include "printer_temperature_state.h"
#include "static_panel_registry.h"
#include "temperature_history_manager.h"
#include "temperature_sensor_manager.h"
#include "temperature_sensor_types.h"
#include "theme_manager.h"
#include "ui_error_reporting.h"
#include "ui_heater_config.h"
#include "ui_component_keypad.h"
#include "ui_nav_manager.h"
#include "ui_panel_temp_control.h"
#include "ui_temperature_utils.h"
#include "ui_utils.h"

#include <spdlog/spdlog.h>

#include <algorithm>
#include <chrono>
#include <cstring>

using helix::ui::observe_int_sync;
using helix::ui::temperature::centi_to_degrees;
using helix::ui::temperature::centi_to_degrees_f;

// ─────────────────────────────────────────────────────────────────────────────
// Color palette: nozzle=red, bed=cyan, chamber=green, then 5 more
// ─────────────────────────────────────────────────────────────────────────────

const lv_color_t TempGraphOverlay::SERIES_COLORS[PALETTE_SIZE] = {
    lv_color_hex(0xFF4444), // Nozzle (red)
    lv_color_hex(0x88C0D0), // Bed (cyan / nord8)
    lv_color_hex(0xA3BE8C), // Chamber (green / nord14)
    lv_color_hex(0xEBCB8B), // Yellow / nord13
    lv_color_hex(0xB48EAD), // Purple / nord15
    lv_color_hex(0xD08770), // Orange / nord12
    lv_color_hex(0x5E81AC), // Blue / nord10
    lv_color_hex(0xBF616A), // Dark red / nord11
};

// ─────────────────────────────────────────────────────────────────────────────
// Global instance
// ─────────────────────────────────────────────────────────────────────────────

static std::unique_ptr<TempGraphOverlay> g_temp_graph_overlay;

TempGraphOverlay& get_global_temp_graph_overlay() {
    if (!g_temp_graph_overlay) {
        g_temp_graph_overlay = std::make_unique<TempGraphOverlay>();
        StaticPanelRegistry::instance().register_destroy("TempGraphOverlay",
                                                          []() { g_temp_graph_overlay.reset(); });
    }
    return *g_temp_graph_overlay;
}

// ─────────────────────────────────────────────────────────────────────────────
// Construction / Destruction
// ─────────────────────────────────────────────────────────────────────────────

TempGraphOverlay::TempGraphOverlay() = default;

TempGraphOverlay::~TempGraphOverlay() {
    teardown_observers();
    if (graph_) {
        ui_temp_graph_destroy(graph_);
        graph_ = nullptr;
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// OverlayBase interface
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::init_subjects() {
    init_subjects_guarded([this]() {
        // No custom subjects needed — graph and chips are fully imperative
    });
}

void TempGraphOverlay::register_callbacks() {
    lv_xml_register_event_cb(nullptr, "on_temp_graph_preset_clicked",
                             on_temp_graph_preset_clicked);
    lv_xml_register_event_cb(nullptr, "on_temp_graph_custom_clicked",
                             on_temp_graph_custom_clicked);
}

lv_obj_t* TempGraphOverlay::create(lv_obj_t* parent) {
    if (!create_overlay_from_xml(parent, "temp_graph_overlay")) {
        return nullptr;
    }

    chip_row_ = lv_obj_find_by_name(overlay_root_, "chip_row");
    graph_container_ = lv_obj_find_by_name(overlay_root_, "graph_container");
    control_strip_ = lv_obj_find_by_name(overlay_root_, "control_strip");
    control_temp_label_ = lv_obj_find_by_name(overlay_root_, "control_temp_label");
    preset_grid_ = lv_obj_find_by_name(overlay_root_, "preset_grid");
    extruder_selector_row_ = lv_obj_find_by_name(overlay_root_, "extruder_selector_row");

    return overlay_root_;
}

void TempGraphOverlay::on_activate() {
    OverlayBase::on_activate();
    *alive_ = true;

    // Resolve dependencies
    printer_state_ = &get_printer_state();
    api_ = get_moonraker_api();
    temp_control_panel_ =
        helix::PanelWidgetManager::instance().shared_resource<TempControlPanel>();
    // Discover all temperature series
    discover_series();

    // Create graph widget
    if (graph_container_ && !graph_) {
        graph_ = ui_temp_graph_create(graph_container_);
        if (graph_) {
            ui_temp_graph_set_temp_range(graph_, Y_AXIS_MIN, y_axis_max_);
            ui_temp_graph_set_y_axis(graph_, Y_AXIS_STEP, true);
            ui_temp_graph_set_axis_size(graph_, "sm");
        }
    }

    // Add series to graph
    if (graph_) {
        for (size_t i = 0; i < series_.size(); ++i) {
            auto& s = series_[i];
            s.series_id = ui_temp_graph_add_series(graph_, s.display_name.c_str(), s.color);
            if (s.series_id >= 0) {
                ui_temp_graph_set_series_gradient(graph_, s.series_id,
                                                  UI_TEMP_GRAPH_GRADIENT_TOP_OPA,
                                                  UI_TEMP_GRAPH_GRADIENT_BOTTOM_OPA);
            }
        }
    }

    // Create chip toggles
    create_chips();

    // Replay history
    replay_history();

    // Set up live observers
    setup_observers();

    // Configure control strip for current mode
    configure_control_strip();

    spdlog::debug("[TempGraphOverlay] Activated with {} series, mode={}",
                  series_.size(), static_cast<int>(mode_));
}

void TempGraphOverlay::on_deactivate() {
    *alive_ = false;
    teardown_observers();

    // Destroy graph (will be recreated on next activate)
    if (graph_) {
        ui_temp_graph_destroy(graph_);
        graph_ = nullptr;
    }

    // Clear series
    series_.clear();

    // Clear chip row
    if (chip_row_) {
        lv_obj_clean(chip_row_);
    }

    OverlayBase::on_deactivate();
    spdlog::debug("[TempGraphOverlay] Deactivated");
}

void TempGraphOverlay::cleanup() {
    teardown_observers();
    if (graph_) {
        ui_temp_graph_destroy(graph_);
        graph_ = nullptr;
    }
    series_.clear();
    OverlayBase::cleanup();
}

// ─────────────────────────────────────────────────────────────────────────────
// Public API
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::open(Mode mode, lv_obj_t* parent_screen) {
    mode_ = mode;

    // Lazy create
    if (!cached_overlay_ && parent_screen) {
        if (!are_subjects_initialized()) {
            init_subjects();
        }

        cached_overlay_ = create(parent_screen);
        if (!cached_overlay_) {
            spdlog::error("[TempGraphOverlay] Failed to create overlay from XML");
            NOTIFY_ERROR("Failed to open temperature graph");
            return;
        }

        NavigationManager::instance().register_overlay_instance(cached_overlay_, this);
        spdlog::info("[TempGraphOverlay] Overlay created");
    }

    if (cached_overlay_) {
        NavigationManager::instance().push_overlay(cached_overlay_);
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Series discovery
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::discover_series() {
    series_.clear();
    int color_idx = 0;

    if (!printer_state_) return;

    const auto& temp_state = printer_state_->temperature_state();

    // 1. Nozzle(s)
    const auto& extruders = temp_state.extruders();
    if (extruders.empty()) {
        // Fallback: always add at least one nozzle
        SeriesInfo s;
        s.display_name = "Nozzle";
        s.heater_name = "extruder";
        s.klipper_name = "extruder";
        s.color = SERIES_COLORS[color_idx++ % PALETTE_SIZE];
        s.has_target = true;
        s.is_dynamic = false;
        series_.push_back(std::move(s));
    } else {
        // Sort extruders by name for consistent ordering
        std::vector<const helix::ExtruderInfo*> sorted_extruders;
        for (const auto& [name, info] : extruders) {
            sorted_extruders.push_back(&info);
        }
        std::sort(sorted_extruders.begin(), sorted_extruders.end(),
                  [](const auto* a, const auto* b) { return a->name < b->name; });

        for (const auto* ext : sorted_extruders) {
            SeriesInfo s;
            s.display_name = ext->display_name;
            s.heater_name = ext->name;
            s.klipper_name = ext->name;
            s.color = SERIES_COLORS[color_idx++ % PALETTE_SIZE];
            s.has_target = true;
            s.is_dynamic = (extruders.size() > 1); // Dynamic if multi-extruder
            series_.push_back(std::move(s));
        }
    }

    // 2. Bed
    {
        SeriesInfo s;
        s.display_name = "Bed";
        s.heater_name = "heater_bed";
        s.klipper_name = "heater_bed";
        s.color = SERIES_COLORS[color_idx++ % PALETTE_SIZE];
        s.has_target = true;
        s.is_dynamic = false;
        series_.push_back(std::move(s));
    }

    // 3. Chamber (if present)
    {
        lv_subject_t* chamber_gate = lv_xml_get_subject(nullptr, "printer_has_chamber_sensor");
        if (chamber_gate && lv_subject_get_int(chamber_gate) != 0) {
            SeriesInfo s;
            s.display_name = "Chamber";
            s.heater_name = "chamber"; // TemperatureHistoryManager might not track this
            s.klipper_name = temp_state.chamber_heater_name();
            s.color = SERIES_COLORS[color_idx++ % PALETTE_SIZE];
            s.has_target = !s.klipper_name.empty();
            s.is_dynamic = false;
            series_.push_back(std::move(s));
        }
    }

    // 4. Custom sensors from TemperatureSensorManager
    auto& sensor_mgr = helix::sensors::TemperatureSensorManager::instance();
    auto sensors = sensor_mgr.get_sensors_sorted();
    for (const auto& sensor : sensors) {
        // Skip sensors with chamber role (already handled above)
        if (sensor.role == helix::sensors::TemperatureSensorRole::CHAMBER) continue;
        // Skip disabled sensors
        if (!sensor.enabled) continue;

        SeriesInfo s;
        s.display_name = sensor.display_name;
        s.heater_name = sensor.klipper_name; // May not have history
        s.klipper_name = sensor.klipper_name;
        s.color = SERIES_COLORS[color_idx++ % PALETTE_SIZE];
        s.has_target = (sensor.type == helix::sensors::TemperatureSensorType::TEMPERATURE_FAN);
        s.is_dynamic = true;
        series_.push_back(std::move(s));
    }

    spdlog::debug("[TempGraphOverlay] Discovered {} series", series_.size());
}

// ─────────────────────────────────────────────────────────────────────────────
// Chip creation
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::create_chips() {
    if (!chip_row_) return;

    lv_obj_clean(chip_row_);

    for (size_t i = 0; i < series_.size(); ++i) {
        auto& s = series_[i];

        // Create a chip button: colored dot + label
        lv_obj_t* chip = lv_obj_create(chip_row_);
        lv_obj_set_size(chip, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
        lv_obj_set_style_pad_hor(chip, theme_manager_get_spacing("space_sm"), 0);
        lv_obj_set_style_pad_ver(chip, theme_manager_get_spacing("space_xxs"), 0);
        lv_obj_set_style_radius(chip, LV_RADIUS_CIRCLE, 0);
        lv_obj_set_style_bg_opa(chip, LV_OPA_COVER, 0);
        lv_obj_set_style_bg_color(chip, theme_manager_get_color("card_bg"), 0);
        lv_obj_set_style_border_width(chip, 1, 0);
        lv_obj_set_style_border_color(chip, theme_manager_get_color("border"), 0);
        lv_obj_set_flex_flow(chip, LV_FLEX_FLOW_ROW);
        lv_obj_set_flex_align(chip, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER,
                              LV_FLEX_ALIGN_CENTER);
        lv_obj_set_style_pad_gap(chip, theme_manager_get_spacing("space_xxs"), 0);
        lv_obj_remove_flag(chip, LV_OBJ_FLAG_SCROLLABLE);
        lv_obj_add_flag(chip, LV_OBJ_FLAG_CLICKABLE);

        // Color dot
        lv_obj_t* dot = lv_obj_create(chip);
        lv_obj_set_size(dot, 8, 8);
        lv_obj_set_style_radius(dot, LV_RADIUS_CIRCLE, 0);
        lv_obj_set_style_bg_opa(dot, LV_OPA_COVER, 0);
        lv_obj_set_style_bg_color(dot, s.color, 0);
        lv_obj_set_style_border_width(dot, 0, 0);
        lv_obj_remove_flag(dot, static_cast<lv_obj_flag_t>(LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE));
        lv_obj_add_flag(dot, LV_OBJ_FLAG_EVENT_BUBBLE);

        // Label
        lv_obj_t* label = lv_label_create(chip);
        lv_label_set_text(label, s.display_name.c_str());
        lv_obj_set_style_text_font(label, theme_manager_get_font("font_small"), 0);
        lv_obj_set_style_text_color(label, theme_manager_get_color("text_primary"), 0);
        lv_obj_remove_flag(label, LV_OBJ_FLAG_CLICKABLE);
        lv_obj_add_flag(label, LV_OBJ_FLAG_EVENT_BUBBLE);

        // Store index as user data for click handler
        lv_obj_set_user_data(chip, reinterpret_cast<void*>(i));
        lv_obj_add_event_cb(chip, on_chip_clicked, LV_EVENT_CLICKED, this);

        s.chip = chip;
        s.visible = true;
    }
}

void TempGraphOverlay::on_chip_clicked(lv_event_t* e) {
    auto* self = static_cast<TempGraphOverlay*>(lv_event_get_user_data(e));
    auto* target = static_cast<lv_obj_t*>(lv_event_get_current_target(e));
    if (!self || !target) return;

    auto idx = reinterpret_cast<size_t>(lv_obj_get_user_data(target));
    if (idx < self->series_.size()) {
        self->toggle_series_visibility(idx);
    }
}

void TempGraphOverlay::toggle_series_visibility(size_t series_idx) {
    if (series_idx >= series_.size()) return;
    auto& s = series_[series_idx];

    s.visible = !s.visible;
    if (graph_ && s.series_id >= 0) {
        ui_temp_graph_show_series(graph_, s.series_id, s.visible);
        if (s.has_target) {
            ui_temp_graph_show_target(graph_, s.series_id, s.visible);
        }
    }
    update_chip_style(series_idx);
    update_y_axis_range();

    spdlog::debug("[TempGraphOverlay] {} series '{}' (idx={})",
                  s.visible ? "Showed" : "Hid", s.display_name, series_idx);
}

void TempGraphOverlay::update_chip_style(size_t series_idx) {
    if (series_idx >= series_.size()) return;
    auto& s = series_[series_idx];
    if (!s.chip) return;

    lv_opa_t opa = s.visible ? LV_OPA_COVER : LV_OPA_40;
    lv_obj_set_style_opa(s.chip, opa, 0);
}

// ─────────────────────────────────────────────────────────────────────────────
// Observer setup/teardown
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::setup_observers() {
    if (!printer_state_) return;

    std::weak_ptr<bool> weak_alive = alive_;

    for (size_t i = 0; i < series_.size(); ++i) {
        auto& s = series_[i];

        // Determine temperature subject
        lv_subject_t* temp_subj = nullptr;
        lv_subject_t* target_subj = nullptr;

        if (s.heater_name == "heater_bed") {
            temp_subj = printer_state_->get_bed_temp_subject();
            target_subj = printer_state_->get_bed_target_subject();
        } else if (s.heater_name == "chamber") {
            temp_subj = printer_state_->get_chamber_temp_subject();
            target_subj = printer_state_->get_chamber_target_subject();
        } else if (s.heater_name.find("extruder") == 0) {
            // Per-extruder subject
            if (printer_state_->extruder_count() <= 1) {
                // Single extruder: use active extruder subjects (static)
                temp_subj = printer_state_->get_active_extruder_temp_subject();
                target_subj = printer_state_->get_active_extruder_target_subject();
            } else {
                // Multi-extruder: use per-extruder subjects (dynamic)
                temp_subj = printer_state_->get_extruder_temp_subject(s.heater_name, s.lifetime);
                target_subj = printer_state_->get_extruder_target_subject(s.heater_name, s.lifetime);
            }
        } else {
            // Custom sensor from TemperatureSensorManager
            auto& sensor_mgr = helix::sensors::TemperatureSensorManager::instance();
            temp_subj = sensor_mgr.get_temp_subject(s.klipper_name, s.lifetime);
        }

        if (temp_subj) {
            size_t idx = i; // Capture by value
            s.temp_observer = observe_int_sync<TempGraphOverlay>(
                temp_subj, this,
                [weak_alive, idx](TempGraphOverlay* self, int temp) {
                    if (weak_alive.expired()) return;
                    self->on_series_temp_changed(idx, temp);
                },
                s.lifetime);
        }

        if (target_subj && s.has_target) {
            size_t idx = i;
            s.target_observer = observe_int_sync<TempGraphOverlay>(
                target_subj, this,
                [weak_alive, idx](TempGraphOverlay* self, int target) {
                    if (weak_alive.expired()) return;
                    self->on_series_target_changed(idx, target);
                },
                s.lifetime);
        }
    }
}

void TempGraphOverlay::teardown_observers() {
    for (auto& s : series_) {
        s.temp_observer.reset();
        s.target_observer.reset();
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// History replay
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::replay_history() {
    auto* history_mgr = get_temperature_history_manager();
    if (!graph_ || !history_mgr) return;

    for (auto& s : series_) {
        if (s.series_id < 0) continue;

        auto samples = history_mgr->get_samples(s.heater_name);
        if (samples.empty()) continue;

        for (const auto& sample : samples) {
            float temp_deg = centi_to_degrees_f(sample.temp_centi);
            ui_temp_graph_update_series_with_time(graph_, s.series_id,
                                                  temp_deg, sample.timestamp_ms);
        }

        // Set initial target if available
        if (s.has_target && !samples.empty()) {
            float target_deg = centi_to_degrees_f(samples.back().target_centi);
            if (target_deg > 0.0f) {
                ui_temp_graph_set_series_target(graph_, s.series_id, target_deg, true);
            }
        }
    }

    update_y_axis_range();
}

// ─────────────────────────────────────────────────────────────────────────────
// Graph updates
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::on_series_temp_changed(size_t series_idx, int temp_centi) {
    if (series_idx >= series_.size()) return;
    auto& s = series_[series_idx];

    if (graph_ && s.series_id >= 0) {
        float temp_deg = centi_to_degrees_f(temp_centi);
        auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                          std::chrono::system_clock::now().time_since_epoch())
                          .count();
        ui_temp_graph_update_series_with_time(graph_, s.series_id, temp_deg, now_ms);
        update_y_axis_range();
    }

    // Update control display if this is the active heater
    update_control_temp_display();
}

void TempGraphOverlay::on_series_target_changed(size_t series_idx, int target_centi) {
    if (series_idx >= series_.size()) return;
    auto& s = series_[series_idx];

    if (graph_ && s.series_id >= 0) {
        float target_deg = centi_to_degrees_f(target_centi);
        bool show = target_deg > 0.0f;
        ui_temp_graph_set_series_target(graph_, s.series_id, target_deg, show);
    }

    update_control_temp_display();
}

void TempGraphOverlay::update_y_axis_range() {
    if (!graph_) return;

    // Find max temperature across visible series
    float max_temp = 0.0f;
    for (const auto& s : series_) {
        if (!s.visible || s.series_id < 0) continue;
        // Use the graph's internal tracking
        for (int j = 0; j < graph_->series_count; ++j) {
            auto& meta = graph_->series_meta[j];
            if (meta.id == s.series_id && meta.visible) {
                if (meta.target_temp > max_temp) max_temp = meta.target_temp;
            }
        }
    }

    // Also consider graph's max_visible_temp
    if (graph_->max_visible_temp > max_temp) {
        max_temp = graph_->max_visible_temp;
    }

    // Auto-scale with hysteresis
    float new_max = y_axis_max_;
    if (max_temp > y_axis_max_ * Y_EXPAND_THRESHOLD) {
        // Expand: round up to next step
        new_max = (std::floor(max_temp / Y_AXIS_STEP) + 1.0f) * Y_AXIS_STEP;
    } else if (max_temp < y_axis_max_ * Y_SHRINK_THRESHOLD && y_axis_max_ > Y_AXIS_FLOOR) {
        // Shrink: round up to next step (but not below floor)
        new_max = std::max(Y_AXIS_FLOOR, (std::floor(max_temp / Y_AXIS_STEP) + 1.0f) * Y_AXIS_STEP);
    }

    new_max = std::min(new_max, Y_AXIS_CEILING);
    new_max = std::max(new_max, Y_AXIS_FLOOR);

    if (new_max != y_axis_max_) {
        y_axis_max_ = new_max;
        ui_temp_graph_set_temp_range(graph_, Y_AXIS_MIN, y_axis_max_);
        spdlog::debug("[TempGraphOverlay] Y-axis range: {}-{}°C", Y_AXIS_MIN, y_axis_max_);
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Control strip
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::configure_control_strip() {
    if (!control_strip_) return;

    bool show_controls = (mode_ != Mode::GraphOnly);

    if (show_controls) {
        lv_obj_remove_flag(control_strip_, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(control_strip_, LV_OBJ_FLAG_HIDDEN);
        return;
    }

    // Get heater type for this mode
    helix::HeaterType heater_type;
    switch (mode_) {
    case Mode::Nozzle:
        heater_type = helix::HeaterType::Nozzle;
        break;
    case Mode::Bed:
        heater_type = helix::HeaterType::Bed;
        break;
    case Mode::Chamber:
        heater_type = helix::HeaterType::Chamber;
        break;
    default:
        return;
    }

    // Get preset config from TempControlPanel
    if (!temp_control_panel_) return;
    auto& heater = temp_control_panel_->heater(heater_type);

    // Hide controls if chamber is sensor-only
    if (mode_ == Mode::Chamber && heater.read_only) {
        lv_obj_add_flag(control_strip_, LV_OBJ_FLAG_HIDDEN);
        return;
    }

    // Configure preset buttons
    const char* preset_names[] = {"preset_off", "preset_1", "preset_2", "preset_3"};
    int preset_values[] = {heater.config.presets.off, heater.config.presets.pla,
                           heater.config.presets.petg, heater.config.presets.abs};

    lv_obj_t* overlay_content = overlay_root_;
    for (int i = 0; i < MAX_PRESETS; ++i) {
        lv_obj_t* btn = lv_obj_find_by_name(overlay_content, preset_names[i]);
        if (btn) {
            // Set user data for callback
            preset_data_[i] = {this, preset_values[i]};
            lv_obj_set_user_data(btn, &preset_data_[i]);
        }
    }

    // Extruder selector: show only in nozzle mode with multiple extruders
    if (extruder_selector_row_) {
        auto& temp_state = printer_state_->temperature_state();
        if (mode_ == Mode::Nozzle && temp_state.extruder_count() > 1) {
            lv_obj_remove_flag(extruder_selector_row_, LV_OBJ_FLAG_HIDDEN);
            rebuild_extruder_selector();
        } else {
            lv_obj_add_flag(extruder_selector_row_, LV_OBJ_FLAG_HIDDEN);
        }
    }

    update_control_temp_display();
}

void TempGraphOverlay::update_control_temp_display() {
    if (!control_temp_label_ || mode_ == Mode::GraphOnly || !printer_state_) return;

    int current_centi = 0;
    int target_centi = 0;

    switch (mode_) {
    case Mode::Nozzle:
        current_centi = lv_subject_get_int(printer_state_->get_active_extruder_temp_subject());
        target_centi = lv_subject_get_int(printer_state_->get_active_extruder_target_subject());
        break;
    case Mode::Bed:
        current_centi = lv_subject_get_int(printer_state_->get_bed_temp_subject());
        target_centi = lv_subject_get_int(printer_state_->get_bed_target_subject());
        break;
    case Mode::Chamber:
        current_centi = lv_subject_get_int(printer_state_->get_chamber_temp_subject());
        target_centi = lv_subject_get_int(printer_state_->get_chamber_target_subject());
        break;
    default:
        break;
    }

    int current_deg = centi_to_degrees(current_centi);
    int target_deg = centi_to_degrees(target_centi);

    char buf[64];
    if (target_deg > 0) {
        snprintf(buf, sizeof(buf), "%d°C → %d°C", current_deg, target_deg);
    } else {
        snprintf(buf, sizeof(buf), "%d°C", current_deg);
    }
    lv_label_set_text(control_temp_label_, buf);
}

// ─────────────────────────────────────────────────────────────────────────────
// Preset / Custom callbacks
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::on_temp_graph_preset_clicked(lv_event_t* e) {
    auto* btn = static_cast<lv_obj_t*>(lv_event_get_current_target(e));
    auto* data = static_cast<PresetData*>(lv_obj_get_user_data(btn));
    if (!data || !data->overlay) return;

    auto* self = data->overlay;
    if (!self->temp_control_panel_) return;

    helix::HeaterType type;
    switch (self->mode_) {
    case Mode::Nozzle:
        type = helix::HeaterType::Nozzle;
        break;
    case Mode::Bed:
        type = helix::HeaterType::Bed;
        break;
    case Mode::Chamber:
        type = helix::HeaterType::Chamber;
        break;
    default:
        return;
    }

    spdlog::debug("[TempGraphOverlay] Preset clicked: {}°C for heater {}",
                  data->preset_value, static_cast<int>(type));

    // Delegate to TempControlPanel for the actual API call
    self->temp_control_panel_->set_heater(type, self->temp_control_panel_->heater(type).current,
                                           data->preset_value * 10);

    // Send the temperature command
    if (self->api_) {
        auto& heater = self->temp_control_panel_->heater(type);
        const std::string& klipper_name =
            (type == helix::HeaterType::Nozzle) ? self->active_extruder_name_
                                                 : heater.klipper_name;
        self->api_->set_temperature(
            klipper_name, static_cast<double>(data->preset_value),
            []() {},
            [](const MoonrakerError& error) {
                NOTIFY_ERROR("Failed to set temperature: {}", error.user_message());
            });
    }
}

void TempGraphOverlay::on_temp_graph_custom_clicked(lv_event_t* e) {
    (void)e;
    auto* overlay_ptr = &get_global_temp_graph_overlay();
    if (!overlay_ptr || !overlay_ptr->temp_control_panel_) return;

    helix::HeaterType type;
    switch (overlay_ptr->mode_) {
    case Mode::Nozzle:
        type = helix::HeaterType::Nozzle;
        break;
    case Mode::Bed:
        type = helix::HeaterType::Bed;
        break;
    case Mode::Chamber:
        type = helix::HeaterType::Chamber;
        break;
    default:
        return;
    }

    auto& heater = overlay_ptr->temp_control_panel_->heater(type);

    // Store context for keypad callback (static because keypad outlives this scope)
    // alive_guard protects against overlay destruction while keypad is open
    static struct {
        TempGraphOverlay* overlay;
        helix::HeaterType type;
        std::weak_ptr<bool> alive_guard;
    } s_keypad_ctx;
    s_keypad_ctx = {overlay_ptr, type, overlay_ptr->alive_};

    ui_keypad_config_t keypad_config = {
        .initial_value = static_cast<float>(heater.target / 10),
        .min_value = heater.config.keypad_range.min,
        .max_value = heater.config.keypad_range.max,
        .title_label = heater.config.title,
        .unit_label = "°C",
        .allow_decimal = false,
        .allow_negative = false,
        .callback = keypad_value_cb,
        .user_data = &s_keypad_ctx,
    };

    ui_keypad_show(&keypad_config);
}

void TempGraphOverlay::keypad_value_cb(float value, void* user_data) {
    struct KeypadCtx {
        TempGraphOverlay* overlay;
        helix::HeaterType type;
        std::weak_ptr<bool> alive_guard;
    };
    auto* ctx = static_cast<KeypadCtx*>(user_data);
    if (!ctx || !ctx->overlay || ctx->alive_guard.expired() || !ctx->overlay->api_) return;

    int temp = static_cast<int>(value);
    auto& heater = ctx->overlay->temp_control_panel_->heater(ctx->type);
    const std::string& klipper_name =
        (ctx->type == helix::HeaterType::Nozzle) ? ctx->overlay->active_extruder_name_
                                                   : heater.klipper_name;

    spdlog::debug("[TempGraphOverlay] Custom temperature: {}°C for {}", temp, klipper_name);

    ctx->overlay->api_->set_temperature(
        klipper_name, static_cast<double>(temp),
        []() {},
        [](const MoonrakerError& error) {
            NOTIFY_ERROR("Failed to set temperature: {}", error.user_message());
        });
}

// ─────────────────────────────────────────────────────────────────────────────
// Extruder selector
// ─────────────────────────────────────────────────────────────────────────────

void TempGraphOverlay::rebuild_extruder_selector() {
    if (!extruder_selector_row_ || !printer_state_) return;

    lv_obj_clean(extruder_selector_row_);

    auto& temp_state = printer_state_->temperature_state();
    const auto& extruders = temp_state.extruders();

    // Sort for consistent ordering
    std::vector<const helix::ExtruderInfo*> sorted;
    for (const auto& [name, info] : extruders) {
        sorted.push_back(&info);
    }
    std::sort(sorted.begin(), sorted.end(),
              [](const auto* a, const auto* b) { return a->name < b->name; });

    for (const auto* ext : sorted) {
        lv_obj_t* btn = lv_obj_create(extruder_selector_row_);
        lv_obj_set_size(btn, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
        lv_obj_set_style_pad_all(btn, theme_manager_get_spacing("space_xs"), 0);
        lv_obj_set_style_radius(btn, theme_manager_get_spacing("space_xs"), 0);
        lv_obj_set_style_bg_opa(btn, LV_OPA_COVER, 0);
        lv_obj_remove_flag(btn, LV_OBJ_FLAG_SCROLLABLE);
        lv_obj_add_flag(btn, LV_OBJ_FLAG_CLICKABLE);

        bool is_active = (ext->name == active_extruder_name_);
        lv_obj_set_style_bg_color(btn, is_active ? theme_manager_get_color("primary")
                                                  : theme_manager_get_color("card_bg"), 0);

        lv_obj_t* label = lv_label_create(btn);
        lv_label_set_text(label, ext->display_name.c_str());
        lv_obj_set_style_text_font(label, theme_manager_get_font("font_small"), 0);
        lv_obj_set_style_text_color(label, is_active ? theme_manager_get_color("on_primary")
                                                      : theme_manager_get_color("text_primary"), 0);
        lv_obj_remove_flag(label, LV_OBJ_FLAG_CLICKABLE);
        lv_obj_add_flag(label, LV_OBJ_FLAG_EVENT_BUBBLE);

        // Store name as obj name for lookup in callback
        lv_obj_set_name(btn, ext->name.c_str());
        lv_obj_add_event_cb(btn, on_extruder_selected, LV_EVENT_CLICKED, this);
    }
}

void TempGraphOverlay::on_extruder_selected(lv_event_t* e) {
    auto* self = static_cast<TempGraphOverlay*>(lv_event_get_user_data(e));
    auto* target = static_cast<lv_obj_t*>(lv_event_get_current_target(e));
    if (!self || !target) return;

    const char* name = lv_obj_get_name(target);
    if (!name) return;

    self->active_extruder_name_ = name;
    self->printer_state_->set_active_extruder(name);
    self->rebuild_extruder_selector();
    self->update_control_temp_display();

    spdlog::debug("[TempGraphOverlay] Selected extruder: {}", name);
}
