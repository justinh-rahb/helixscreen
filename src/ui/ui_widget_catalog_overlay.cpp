// SPDX-License-Identifier: GPL-3.0-or-later

#include "ui_widget_catalog_overlay.h"

#include "ui_fonts.h"
#include "ui_nav_manager.h"

#include "panel_widget_config.h"
#include "panel_widget_registry.h"
#include "theme_manager.h"

#include <lvgl/lvgl.h>
#include <spdlog/spdlog.h>

#include <string>

namespace helix {

// ============================================================================
// State shared between the overlay and row click callbacks.
// Only one catalog overlay can be open at a time.
// ============================================================================

namespace {

struct CatalogState {
    lv_obj_t* overlay_root = nullptr;
    WidgetSelectedCallback on_select;
    CatalogClosedCallback on_close;
};

CatalogState g_catalog_state;

void close_catalog() {
    if (g_catalog_state.overlay_root) {
        auto on_close = std::move(g_catalog_state.on_close);
        NavigationManager::instance().go_back();
        g_catalog_state.overlay_root = nullptr;
        g_catalog_state.on_select = nullptr;
        g_catalog_state.on_close = nullptr;
        if (on_close) {
            on_close();
        }
    }
}

} // namespace

// ============================================================================
// Row creation
// ============================================================================

lv_obj_t* WidgetCatalogOverlay::create_row(lv_obj_t* parent, const char* name, int colspan,
                                           int rowspan, bool already_placed) {
    // Row container: horizontal, fixed height
    lv_obj_t* row = lv_obj_create(parent);
    lv_obj_set_width(row, LV_PCT(100));
    lv_obj_set_height(row, LV_SIZE_CONTENT);
    lv_obj_set_style_pad_all(row, 10, 0);
    lv_obj_set_style_pad_gap(row, 8, 0);
    lv_obj_set_style_bg_color(row, theme_manager_get_color("card_bg"), 0);
    lv_obj_set_style_bg_opa(row, LV_OPA_COVER, 0);
    lv_obj_set_style_radius(row, 8, 0);
    lv_obj_set_style_border_width(row, 0, 0);
    lv_obj_set_layout(row, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(row, LV_FLEX_FLOW_ROW);
    lv_obj_set_style_flex_cross_place(row, LV_FLEX_ALIGN_CENTER, 0);
    lv_obj_set_style_flex_main_place(row, LV_FLEX_ALIGN_SPACE_BETWEEN, 0);
    lv_obj_remove_flag(row, LV_OBJ_FLAG_SCROLLABLE);

    if (already_placed) {
        lv_obj_set_style_opa(row, LV_OPA_40, 0);
        lv_obj_remove_flag(row, LV_OBJ_FLAG_CLICKABLE);
    } else {
        lv_obj_add_flag(row, LV_OBJ_FLAG_CLICKABLE);
        // Pressed feedback
        lv_obj_set_style_bg_color(row, theme_get_accent_color(), LV_PART_MAIN | LV_STATE_PRESSED);
        lv_obj_set_style_bg_opa(row, LV_OPA_20, LV_PART_MAIN | LV_STATE_PRESSED);
    }

    // Left side: widget name
    lv_obj_t* name_label = lv_label_create(row);
    lv_label_set_text(name_label, name);
    lv_obj_set_style_text_font(name_label, &noto_sans_16, 0);
    lv_obj_set_style_text_color(name_label, theme_manager_get_color("text"), 0);
    lv_obj_set_flex_grow(name_label, 1);

    // Right side: size badge + optional "Placed" label
    lv_obj_t* right_group = lv_obj_create(row);
    lv_obj_set_size(right_group, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
    lv_obj_set_style_pad_all(right_group, 0, 0);
    lv_obj_set_style_pad_gap(right_group, 6, 0);
    lv_obj_set_style_bg_opa(right_group, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(right_group, 0, 0);
    lv_obj_set_layout(right_group, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(right_group, LV_FLEX_FLOW_ROW);
    lv_obj_set_style_flex_cross_place(right_group, LV_FLEX_ALIGN_CENTER, 0);
    lv_obj_remove_flag(right_group, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_remove_flag(right_group, LV_OBJ_FLAG_SCROLLABLE);

    if (already_placed) {
        lv_obj_t* placed_label = lv_label_create(right_group);
        lv_label_set_text(placed_label, "Placed");
        lv_obj_set_style_text_font(placed_label, &noto_sans_12, 0);
        lv_obj_set_style_text_color(placed_label, theme_manager_get_color("text_secondary"), 0);
    }

    // Size badge (e.g. "2x1")
    lv_obj_t* badge = lv_obj_create(right_group);
    lv_obj_set_size(badge, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
    lv_obj_set_style_pad_left(badge, 6, 0);
    lv_obj_set_style_pad_right(badge, 6, 0);
    lv_obj_set_style_pad_top(badge, 2, 0);
    lv_obj_set_style_pad_bottom(badge, 2, 0);
    lv_obj_set_style_bg_color(badge, theme_manager_get_color("secondary"), 0);
    lv_obj_set_style_bg_opa(badge, LV_OPA_COVER, 0);
    lv_obj_set_style_radius(badge, 4, 0);
    lv_obj_set_style_border_width(badge, 0, 0);
    lv_obj_remove_flag(badge, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_remove_flag(badge, LV_OBJ_FLAG_SCROLLABLE);

    char size_text[16];
    snprintf(size_text, sizeof(size_text), "%dx%d", colspan, rowspan);
    lv_obj_t* badge_label = lv_label_create(badge);
    lv_label_set_text(badge_label, size_text);
    lv_obj_set_style_text_font(badge_label, &noto_sans_12, 0);
    lv_obj_set_style_text_color(badge_label, theme_manager_get_color("text_secondary"), 0);

    return row;
}

// ============================================================================
// Populate rows
// ============================================================================

void WidgetCatalogOverlay::populate_rows(lv_obj_t* scroll, const PanelWidgetConfig& config,
                                         WidgetSelectedCallback /*on_select*/) {
    const auto& defs = get_all_widget_defs();

    for (const auto& def : defs) {
        // Determine if already placed (enabled in config)
        bool already_placed = config.is_enabled(def.id);

        const char* display_name = def.display_name ? def.display_name : def.id;

        lv_obj_t* row = create_row(scroll, display_name, def.colspan, def.rowspan, already_placed);

        if (!already_placed) {
            // Store widget ID in user data for the click handler.
            // The ID string comes from the static widget def table, so the pointer is stable.
            lv_obj_set_user_data(row, const_cast<char*>(def.id));

            // Widget pool recycling exception: dynamic row click handler
            lv_obj_add_event_cb(
                row,
                [](lv_event_t* ev) {
                    auto* widget_id = static_cast<const char*>(lv_event_get_user_data(ev));
                    if (!widget_id) {
                        return;
                    }
                    spdlog::info("[WidgetCatalog] Selected widget: {}", widget_id);
                    // Copy callback and ID before closing (close resets state)
                    auto cb = g_catalog_state.on_select;
                    std::string id_copy(widget_id);
                    close_catalog();
                    if (cb) {
                        cb(id_copy);
                    }
                },
                LV_EVENT_CLICKED, const_cast<char*>(def.id));
        }
    }
}

// ============================================================================
// Show
// ============================================================================

void WidgetCatalogOverlay::show(lv_obj_t* parent_screen, const PanelWidgetConfig& config,
                                WidgetSelectedCallback on_select, CatalogClosedCallback on_close) {
    if (g_catalog_state.overlay_root) {
        spdlog::warn("[WidgetCatalog] Already open, ignoring duplicate show()");
        return;
    }

    // Create overlay from XML
    auto* overlay =
        static_cast<lv_obj_t*>(lv_xml_create(parent_screen, "widget_catalog_overlay", nullptr));
    if (!overlay) {
        spdlog::error("[WidgetCatalog] Failed to create widget_catalog_overlay from XML");
        return;
    }

    // Initially hidden (NavigationManager will unhide during push)
    lv_obj_add_flag(overlay, LV_OBJ_FLAG_HIDDEN);

    // Store state
    g_catalog_state.overlay_root = overlay;
    g_catalog_state.on_select = std::move(on_select);
    g_catalog_state.on_close = std::move(on_close);

    // DELETE cleanup exception: detect when NavigationManager pops the overlay
    // without going through close_catalog() (e.g., system back navigation)
    lv_obj_add_event_cb(
        overlay,
        [](lv_event_t* /*e*/) {
            auto on_close_cb = std::move(g_catalog_state.on_close);
            g_catalog_state.overlay_root = nullptr;
            g_catalog_state.on_select = nullptr;
            g_catalog_state.on_close = nullptr;
            if (on_close_cb) {
                on_close_cb();
            }
        },
        LV_EVENT_DELETE, nullptr);

    // Find scroll container and populate
    lv_obj_t* scroll = lv_obj_find_by_name(overlay, "catalog_scroll");
    if (!scroll) {
        spdlog::error("[WidgetCatalog] catalog_scroll not found in XML");
        lv_obj_delete(overlay);
        g_catalog_state.overlay_root = nullptr;
        g_catalog_state.on_select = nullptr;
        return;
    }

    populate_rows(scroll, config, g_catalog_state.on_select);

    // Push onto navigation stack
    NavigationManager::instance().push_overlay(overlay);

    spdlog::info("[WidgetCatalog] Overlay shown with {} widget definitions",
                 get_all_widget_defs().size());
}

} // namespace helix
